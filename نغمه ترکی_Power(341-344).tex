\documentclass[a4,9pt]{beamer}
\usetheme{Singapore}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{graphicx}
\linespread{1.35}
\usepackage{amsmath}
\usepackage{color}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}

\begin{document}
\begin{frame}
\section*{Membership Problem}
\begin{flushright}
\texttt{Context-free Grammar} \hspace*{0.1cm}\textbf{$|$} \hspace*{0.1cm} \textbf{341}\hspace*{0.1cm}
\end{flushright}
\vspace*{0.3cm}

\begin{center}
  \section{picture}
\includegraphics[width=3cm,height=4cm]{341.png}
\end{center}

The graph does not contain any loop. So, the language generated by the CFG is finite. The derivation
from the grammar is $S \rightarrow AB \rightarrow BCB \rightarrow aaa$.\\
\hspace*{0.5cm} Thus, the length of the longest string is 3.\\

\vspace*{0.2cm}
\hspace*{-0.5cm} b) In the grammar, there is a unit production $A \rightarrow B$. By removing the unit production, the grammar
becomes\\
\end{frame}

\begin{frame}
\hspace*{4cm} $S \rightarrow AB$ \\
\hspace*{4cm} $A \rightarrow SC/a$ \\
\hspace*{4cm} $B \rightarrow SC/a$ \\
\hspace*{4cm} $C \rightarrow AB/b$ \\

\vspace*{0.2cm}
The grammar is in CNF. The non-terminal transitional graph for the grammar is shown in Fig. 6.17.\\


\begin{center}
  \section{picture}
\includegraphics[width=3.3cm,height=4.5cm]{341-2.png}
\end{center}

\end{frame}

\begin{frame}
\hspace*{0.5cm} The graph contains loops. So, the language generated by the CFG is infinite.\\
\vspace*{0.2cm}

\large{
\textbf{6.11.3 Membership Problem}\\
}

\vspace*{0.2cm}
\small{
Membership problem decides whether a string w is generated by a given CFG.\\
\hspace*{0.5cm} This is proved by the CYK algorithm. This algorithm was proposed by John Cocke, Daniel Younger,
and Tadao Kasami. According to the algorithm, the string of terminals is generated from length 1 to
length of w, which is also the string to be checked for membership. If w $\in$ the set of string generated,
then w is a member of the strings generated by the CFG. For this, we need to convert the given grammar
into CNF. With the help of an example we are showing this.\\
}
\end{frame}

\begin{frame}
\section*{Membership Problem}
 \begin{flushleft}
    \textbf{342}\hspace*{0.1cm} \textbf{$|$} \hspace*{0.1cm} Introduction to Automata Theory, Formal Languages and Computation
  \end{flushleft}
\vspace*{0.5cm}

\fcolorbox{red}{yellow}{\textcolor{blue}{Example 6.50}} \hspace*{0.2cm} Let the grammar converted to CNF is\\

\vspace*{0.2cm}
\hspace*{4cm} $S \rightarrow C_{b}A/C_{a}B$ \\
\hspace*{4cm} $A \rightarrow C_{b}D/C_{a}S/a$ \\
\hspace*{4cm} $B \rightarrow C_{a}E/C_{b}S/a$ \\
\hspace*{4cm} $D \rightarrow AA$ \\
\hspace*{4cm} $\Sigma \rightarrow BB$ \\
\hspace*{4cm} $C_{a} \rightarrow a$ \\
\hspace*{4cm} $C_{b} \rightarrow b$ \\

\vspace*{0.2cm}
Check whether baba is a member of the CFL generated by the CFG.\\

\vspace*{0.2cm}
\textbf{$Solution$:}Start producing strings of length 1.\\

\vspace*{0.1cm}
\end{frame}

\begin{frame}

\begin{center}
\begin{tabular}{cc}
\hline

\hline

\hline

\hline
String & Producing NT \\
\hline
A & A \\
A & B \\
A & C$_{a}$ \\
B & C$_{b}$ \\
\hline

\hline

\hline

\hline

\end{tabular}
\end{center}

\vspace*{0.1cm}
\hspace*{0.4cm}Produce strings of length 2\\
\vspace*{0.1cm}

\begin{center}
\begin{tabular}{cc}
\hline

\hline

\hline

\hline
String & Producing NT \\
\hline
ba  & $S (S \rightarrow C_{b}A)$ \\
aa  & $S (S \rightarrow C_{a}B)$ \\
aa  & $D (D \rightarrow AA)$ \\
aa  & $E (E \rightarrow BB)$ \\
\hline

\hline

\hline

\hline

\end{tabular}
\end{center}
\vspace*{0.1cm}

\hspace*{0.4cm} Produce strings of length 3. This may be the first one produced by an NT and the last two produced
by another NT or vice versa.\\

\vspace*{0.1cm}
\end{frame}

\begin{frame}
\begin{center}
\begin{tabular}{cc}
\hline

\hline

\hline

\hline
String & Producing NT \\
\hline
baa & $A (A \rightarrow C_{b}D)$ \\
aba & $A (A \rightarrow C_{a}S)$ \\
aaa & $A (A \rightarrow C_{a}S)$ \\
aaa & $B (B \rightarrow C_{a}E)$ \\
bba & $B (B \rightarrow C_{b}S)$ \\
baa & $B (B \rightarrow C_{b}S)$ \\
\hline

\hline

\hline

\hline

\end{tabular}
\end{center}

\vspace*{0.1cm}
\hspace*{0.5cm} Produce strings of length 4. This may be the First one produced by an NT and the last three produced
by another NT or the first two produced by an NT and the last two produced by another NT or the first
three produced by an NT and the last one produced by another NT. Two–two combination is not available
for this grammar as there is no production combining two of S, D, and E.\\
\end{frame}

\begin{frame}
\section*{CFG and Regular Language}
\begin{flushright}
\texttt{Context-free Grammar} \hspace*{0.1cm}\textbf{$|$} \hspace*{0.1cm} \textbf{343}\hspace*{0.1cm}
\end{flushright}
\vspace*{0.1cm}

\tiny{
\begin{center}
\begin{tabular}{cl}
\hline

\hline

\hline

\hline
String & Producing NT \\
\hline
abaa & $D (D \rightarrow AA, A \rightarrow a, A \rightarrow CbD)$ \\
baaa & $D (D \rightarrow AA, A \rightarrow CbD, A \rightarrow a)$ \\
aaba & $D (D \rightarrow AA, A \rightarrow a, A \rightarrow CaS)$ \\
abaa & $D (D \rightarrow AA, A \rightarrow CaS, A \rightarrow a)$ \\
aaaa & $D (D \rightarrow AA, A \rightarrow CaS, A \rightarrow a)$ \\
aaaa & $D (D \rightarrow AA, A \rightarrow a, A \rightarrow CaS)$ \\
aaaa & $E (E \rightarrow BB)$ \\
aaaa & $E (E \rightarrow BB)$ \\
abba & $E (E \rightarrow BB)$ \\
bbaa & $E (E \rightarrow BB)$ \\
abaa & $E (E \rightarrow BB)$ \\
baaa & $E (E \rightarrow BB)$ \\
aaaa & $S (S \rightarrow CaB)$ \\
abba & $S (S \rightarrow CaB)$ \\
abaa & $S (S \rightarrow CaB)$ \\
bbaa & $S (S \rightarrow CbA)$ \\
baba & $S (S \rightarrow CbA)$ \\
baaa & $S (S \rightarrow CbA)$ \\
\hline

\hline

\hline

\hline

\end{tabular}
\end{center}
}

\vspace*{0.2cm}
\hspace*{0.5cm} The string in bold is ‘baba’. Thus, baba is a member of the CFL generated by the CFG.\\

\vspace*{0.1cm}
\end{frame}

\begin{frame}
\large{
\textbf{6.12 CFG and Regular Language}\\
}

\vspace*{0.2cm}
\small{
According to the Chomsky hierarchy, we know that a regular grammar is a subset of CFG. Thus, for
every regular language, there exists a CFG. In this section, we shall discuss two theorems related to this\\

\vspace*{0.2cm}
\textbf{$Theorem 1$}: Every regular language is generated by a CFG. \\

\vspace*{0.2cm}
Proof: Assume that L is regular. Thus, there exists a DFA $M = \{Q, \Sigma, \delta, q_{0}, F\}$ accepting L. From the
DFA M, we can generate a CFG $G = \{V_{N}, \Sigma, P, S \}$ using the following rules.\\
\vspace*{0.1cm}

\begin{enumerate}
  \item Every state $\in Q$ of M is treated as a non-terminal $\in V_{N}$. The start state $S = q_{0}$ (initial state of
DFA).\\
  \item For a transitional function $\delta(q_{1}, a) \rightarrow q_{2}$, where $q_{1}, q_{2} \in Q$ and a $\in \Sigma$, add a production $q_{1} \rightarrow aq_{2}$ in P.\\
  \item If $q_{2}$ is a fi nal state, add $q_{1}\rightarrow aq_{2}$ and $q_{1} \rightarrow a$ in P.\\
\end{enumerate}

\vspace*{0.1cm}
All there productions have a single non-terminal at the LHS. Thus, it is context free.\\

\vspace*{0.2cm}
\textbf{$Theorem 2$:} The language generated by a regular CFG is a regular language. Or every regular grammar
generates a regular language.\\
}
\end{frame}

\begin{frame}
\section*{Applications of Context-free Grammar}
 \begin{flushleft}
    \textbf{344}\hspace*{0.1cm} \textbf{$|$} \hspace*{0.1cm} Introduction to Automata Theory, Formal Languages and Computation
  \end{flushleft}
\vspace*{0.5cm}

Proof: Let $G = \{V_{N}, \Sigma, P, S \}$ be a regular CFG. From this grammar, construct a NDFA $M = \{Q, \Sigma, \delta,
q_{0}, F\}$ using the following rules.\\
\vspace*{0.2cm}

\begin{enumerate}
  \item For each production in the form $<NT_{1}> \rightarrow <i/p> <NT_{2}>$, add a transitional function\\
  
  \begin{center}
    $\delta(<NT_{1}>, <i/p>) \rightarrow <NT_{2}>$ \\
  \end{center}
  
  \item For each production in the form $<NT_{1} > \rightarrow <i/p>$, add a transitional function \\
  
  \begin{center}
    $\delta(<NT_{1}>, <i/p>) \rightarrow $final state \\
  \end{center}
\end{enumerate}

\vspace*{0.2cm}
\small{
We know that a language accepted by an NDFA is regular expression. Thus, it is proved.\\
\hspace*{0.5cm} Every regular grammar is some right linear grammar. Already it is given that a right linear grammar
can be converted to a left linear grammar. Thus, it can be proved that if L is a regular set, then L is
generated by some left linear or some by some right linear grammar.\\
}

\vspace*{0.4cm}
\end{frame}

\begin{frame}
\large{
\textbf{6.13 Applications of Context-free Grammar}\\
}

\vspace*{0.2cm}
\small{
The compiler is a program that takes a program written is the source language as input and translates it
into an equivalent program in the target language. Syntax analysis in an important phase in the compiler
design. In this phase, mainly grammatical errors called syntax errors are checked. The syntax analyzer
(parser) checks whether a given source program satisfies the rules implied by a context-free grammar
or not. If it satisfies, the parser creates the parse tree of that program. Otherwise, the parser gives the
error messages.\\
\hspace*{0.5cm} In C language, an identifier is described by the following CFG.\\
\hspace*{0.5cm} The definition of an identifier in a programming language is\\

\vspace*{0.2cm}
\hspace*{4cm} $letter \rightarrow A | B | . . . | Z | a | b | ... | z$ \\
\hspace*{4cm} $digit \rightarrow 0 | 1 | . . . | 9$ \\
\hspace*{4.5cm} $id \rightarrow letter (letter | digit)_{*}$ \\
\vspace*{0.2cm}

Let a programmer declare the following variables
}
\vspace*{0.2cm}

\end{frame}

\begin{frame}
\hspace*{1cm} int capital;\\
\hspace*{1cm} int r$_{-}$o$_{-}$i;\\
\hspace*{1cm} int year;\\
\hspace*{1cm} int 1st$_{-}$year$_{-}$interest;\\

\vspace*{0.2cm}
then the syntax error will be shown in the fourth line as it does not match with the language produced
by the grammar.\\
\hspace*{0.5cm} For the iteration statements (loop) also, there are CFGs.\\

\vspace*{0.2cm}
\hspace*{1cm} $<$iteration statement$> \rightarrow$ while$(<$logical expression$>) <$statement$>$ \\
\hspace*{2.2cm} $/$do $<$statement$>$ while $(<$logical expression$>)$ \\
\hspace*{2.2cm} $/$for$(<$expression$>$; <expression$>$; <expression$>)$ $<$statement$>$ \\

\vspace*{0.2cm}
\hspace*{0.5cm} The CFG is used to develop extensive markup language (XML). XML is a markup language much
like HTML. XML is used as a database and can be applicable to share and store data. It can even be used
to construct new languages such as WML.\\
\end{frame}
\end{document}


